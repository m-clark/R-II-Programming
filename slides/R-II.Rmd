---
title: "<span class='title'>R II: Programming</span>"
subtitle: "<span class='subtitle'>Data Wrangling</span>"
author: "<span class='author'>Michael Clark</span>"
institute: "<span class='institute'>m-clark.github.io <br> @statsdatasci <br> CSCAR, UM</span>"
date: "<span class='date'>2020-10-13</span>"
css: style.css
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: zenburn
      highlightLines: true
      countIncrementalSlides: false
---
class: inverse

background-image: url(https://github.com/m-clark/m-clark.github.io/raw/master/img/Rlogo.svg)

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE, crayon.enabled = FALSE) # see https://github.com/hadley/mastering-shiny/issues/132

knitr::opts_chunk$set(
  # code
  echo      = T,
  eval      = F,
  message   = F,
  warning   = F,
  error     = F,
  comment   = NA,
  R.options = list(width = 220),
  # viz
  dev.args  = list(bg = 'transparent'),
  dev       = 'svglite',
  fig.align = 'center',
  out.width = '75%',
  fig.asp   = .75,
  # cache
  cache.rebuild = F,
  cache         = F
)

kable_df = function(data, digits=3, ...) {
  kableExtra::kable(
    data,
    digits = digits,
    format = 'html',
    booktabs = T,
    # longtable = F,
    linesep = "",
    ...,
  ) %>% 
    kableExtra::kable_styling(full_width = F)
}

perc = function(x, digits = 1) paste(rnd(x*100, digits = digits), '%')
```

```{r setup-extra, echo=FALSE, eval=TRUE}
xaringanExtra::use_xaringan_extra(
  c(
    "tile_view",
    "animate_css",
    "tachyons",
    'clipboard',
    'fit_screen',
    'webcam',
    'panelset'
  )
)

xaringanExtra::use_logo(
  image_url = 'https://raw.githubusercontent.com/m-clark/m-clark.github.io/master/img/mc_logo.png',
  link_url = 'https://m-clark.github.io',
  width = '5%',
  position =  xaringanExtra::css_position(bottom = "-3em", left = "1em"),
  exclude_class = c("title-slide")
)

xaringanExtra::use_animate_css()

xaringanExtra::style_share_again(
  share_buttons = c("twitter", "linkedin", "pocket")
)
```



```{r setup-packs}
library(tidyverse)
```


---
class: inverse middle center





### *Basics*

### *Iterative Programming*

### *Writing Functions*

### *More*


---
class: inverse middle center animated rollIn rollOut # https://animate.style/


# Basics 
<br>
<br>
<i class="fas fa-laptop-code fa-5x"></i>

---
class: inverse center

# Basics: Objects


--

<br>

## What is an <span class="" style = "text-shadow: 0 0 50px #EBA42BFF">*object*</span>?

--
## Anything!

--

<div class="" style = "font-size:20pt">
data frames<br>

lists<br>

vectors<br>

matrices<br>

strings<br>

plots
</div>



---
class: inverse

# Basics: Objects

Everything in R revolves around the objects we create

```{r}
my_value = 'M'

my_vector = rnorm(100)

my_df = data.frame(A = rnorm(100), B = runif(100))

my_plot = qplot(A, B, data = my_df)

my_list = list(
  my_value,
  my_vector,
  my_df,
  my_plot
)

```



---
class: inverse 

# Basics: Objects

How do we understand them?

--

```{r eval=TRUE}
library(tidyverse)

glimpse(diamonds)
```

---
class: inverse 

# Basics: Objects

```{r eval=TRUE}
lm_mod = lm(mpg ~ ., data=mtcars)

str(lm_mod, 1)  # works for functions too! try str(lm)
```

---
class: inverse 

# Basics: Objects

*Classes* tell us the kind of object we're dealing with.

*Methods* work on different classes.

```{r}
class(diamonds)  # data.frame

summary(diamonds)

class(diamonds$clarity)   # ordered factor

summary(diamonds$clarity)

class(lm_mod)   # lm

summary(lm_mod)
```



---
class: inverse 

# Basics: Objects

```{r eval = T}
methods('summary')
```

---
class: inverse 

# Basics: Documentation

Use the <span class="func" style = "">sample</span> function to get a random sample of 10 values from the numbers 1 to 5. 

```{r help}
sample(?)
```

--
Don't know what to put? 

--

Consult the help file!


---
class: inverse 

# Basics: Documentation

![](img/help.png)

---
class: inverse 

# Basics: Exercises

With one function, find out what the class, number of rows, number of columns are of the following object, including what kind of object the last three columns are. Inspect the help file also.


```{r}
library(dplyr)

?starwars
```


---
class: inverse middle center animated zoomIn rollOut # https://animate.style/


# Iterative Programming
<br>
<br>
<i class="fas fa-sync-alt fa-5x"></i>

---
class: inverse

# Iterative Programming: For Loops

Do you do something like this?

```{r}
means1 = mean(df$x)
means2 = mean(df$y)
means3 = mean(df$z)
means4 = mean(df$q)
```

--

<i class="far fa-times-circle fa-9x" style="position: relative; top: -200px; height: -500px; display: block"></i>

---
class: inverse

# Iterative Programming: For Loops

Write a *loop* instead!

--

```{r}
for (column in c('x','y','z','q')) {
  mean(df[[column]])
}
```

What's going on here? 

--

We've created an iterative process in which:

--

*for* every *element* in `c('x','y','z','q')`... 

--

Do something!

---
class: inverse

# Iterative Programming: For Loops

```{r eval=T}
weather = nycflights13::weather

for (column in c('temp', 'humid', 'wind_speed', 'precip')) {
  print(mean(weather[[column]], na.rm = TRUE))
}
```


---
class: inverse

# Iterative Programming: For Loops

Using *while* is exactly the same.

Useful when you have a specific check 
- a *condition*

```{r eval=T}
columns = c('temp','humid','wind_speed', 'visib', 'pressure')
nyc_means = c()

i = 1

while (i <= length(columns)) {
  nyc_means[i] = mean(weather[[columns[i]]], na.rm = TRUE)
  i = i + 1
}

nyc_means %>% round(2)
```



---
class: inverse

# Iterative Programming: Implicit Loops

We can loop without `for` or `while`!

- <span class="func" style = "">apply</span> family
- <span class="func" style = "">purrr</span> family

---
class: inverse

# Iterative Programming: Implicit Loops

Why?


- Cleaner/simpler code
- Environment clear of unnecessary objects
- Potentially more reproducible
  - more likely to use generalizable functions
- Parallelizable

---
class: inverse

# Iterative Programming: Implicit Loops


*apply*
- arrays, matrices, data.frames

*lapply*, *sapply*, *vapply*
- lists, data.frames, vectors

*tapply*
- grouped operations (table *apply*)

*mapply*
- multivariate version of *sapply*

*replicate*
- performs an operation N times

---
class: inverse

# Iterative Programming: Implicit Loops

How do they work?

```{r, eval=TRUE}
columns = c('temp','humid','wind_speed', 'visib', 'pressure')
apply(weather[columns], 2, mean, na.rm=T)  # 2 for columns, 1 for rows

my_list = list(1, 1:10, 1:20)
lapply(my_list, sum)
```

---
class: inverse

# Iterative Programming: Implicit Loops

How do they work?

Find a function, **apply** it to an object!

```{r, eval=TRUE}
my_list = list(1:3, 4:6, 7:9)
sapply(my_list, sum) # lapply that simplifies if possible

replicate(2, rnorm(3)) # also simplifies if possible
```


---
class: inverse

# Iterative Programming: Implicit Loops

purrr is best with *data.frame* or *list* objects
- works the same way in spirit as `*apply`.
- more control over output
  - more strict about input
  - can be frustrating!

---
class: inverse

# Iterative Programming: Implicit Loops

```{r, eval=TRUE}
map(my_list, sum)

map_int(my_list, sum)

map_df(my_list, ~data.frame(x = sum(.)))
```

---
class: inverse

# Iterative Programming: Implicit Loops

```{r, eval=TRUE}
diamonds %>%
  map_at(
    vars(carat, depth, price),
    function(x)
      x > median(x)
  ) %>% 
  as_tibble()
```

---
class: inverse

# Iterative Programming: Implicit Loops

Faster implicit loops: parallelization!

- <span class="pack" style = "">parallel</span> package in base R
  - <span class="func" style = "">apply</span> family
  - <span class="func" style = "">parApply</span>, <span class="func" style = "">parLapply</span>, etc.
  
  
- <span class="pack" style = "">furrr</span> package 
  - <span class="pack" style = "">purrr</span> functions
  - requires <span class="pack" style = "">futures</span> package
  - <span class="func" style = "">future_map*</span> functions



---
class: inverse slide-title-90

# Iterative Programming: Looping with Lists

<div style="text-align: center;">
<i class="fa fa-list-ol fa-3x"></i>
</div>

Lists are easy to loop!

And we can put anything in them to loop over!


---
class: inverse slide-title-90

# Iterative Programming: Looping with Lists

```{r, eval=TRUE}
library(mgcv) # for gam

mtcars$cyl = factor(mtcars$cyl)

mod_lm = lm(mpg ~ wt, data = mtcars)

mod_poly = lm(mpg ~ poly(wt, 2), data = mtcars)

mod_inter = lm(mpg ~ wt * cyl, data = mtcars)

mod_gam = gam(mpg ~ s(wt), data = mtcars)

mod_gam_inter = gam(mpg ~ cyl + s(wt, by = cyl), data = mtcars)
```




---
class: inverse slide-title-90

# Iterative Programming: Looping with Lists

```{r, eval=T}
model_list = list(
  mod_lm        = mod_lm,
  mod_poly      = mod_poly,
  mod_inter     = mod_inter,
  mod_gam       = mod_gam,
  mod_gam_inter = mod_gam_inter
)

# lowest wins
model_list %>% 
  map_df(AIC) %>% 
  sort()
```


---
class: inverse

# Iterative Programming: Exercises

Exercise 1

With the following matrix, use apply and the sum function to get row or column sums of the matrix x.

```{r}
x = matrix(1:9, 3, 3)
```

---
class: inverse

# Iterative Programming: Exercises


Exercise 2 

Use a map function to create a data frame of the column means. See `?map` to see all your options.

```{r}
d = tibble(
  x = rnorm(100),
  y = rnorm(100, 10, 2),
  z = rnorm(100, 50, 10),
)
```


---
class: inverse middle  center animated bounceInDown rollOut # https://animate.style/

# Functions

<br>
<br>

<i class="fa fa-terminal fa-5x"></i>


---
class: inverse

# Functions: Starting Out

What's a function?

<div style='background-color: #fff; text-align: center'>
<img src="img/function.svg" style="display:block; margin: 0 auto; width: 33%">

</div>

Scary?!

---
class: inverse

# Functions: Starting Out

Not really! 

```{r, eval=TRUE}
square_this = function(x) x^2
add_one     = function(x) x + 1

3 %>% 
  square_this() %>% 
  add_one()
```




---
class: inverse

# Functions: Starting Out

You use functions all the time.

Why not make your own?

Key idea: *reusable code*


---
class: inverse

# Functions: Starting Out

```{r}
mean(myvar)
sd(myvar)
sum(is.na(myvar))
```

Let's create a function that would do this.

And spit out a usable data frame!

--

```{r}
my_summary <- function(x) {
  data.frame(
    mean = mean(x),
    sd = sd(x),
    N_missing = sum(is.na(x))
  )
}
```

---
class: inverse

# Functions: Starting Out

```{r, eval=T}
my_summary <- function(x) {
  data.frame(
    mean = mean(x),
    sd = sd(x),
    N_missing = sum(is.na(x))
  )
}
```


`x` is an arbitrary name for an input. 
  - In R these are called *arguments*
  - These inputs will determine the output


---
class: inverse

# Functions: Starting Out

Typically data has missing values.

```{r, eval=TRUE, echo=FALSE}
load('../../../data-processing-and-visualization/data/gapminder.RData')
```


```{r, eval=F}
load('data/gapminder.RData')
```


```{r, eval=TRUE}
my_summary(gapminder_2019$lifeExp)
```


Let's fix this!

---
class: inverse

# Functions: Starting Out

Since we have a function, we can modify it

```{r, eval=T}
my_summary_na <- function(x, remove_na = TRUE) {
  data.frame(
    mean = mean(x, na.rm = remove_na),
    sd   = sd(x, na.rm = remove_na),
    N_missing = sum(is.na(x))
  )
}

my_summary(gapminder_2019$lifeExp)
my_summary_na(gapminder_2019$lifeExp)
```

---
class: inverse

# Functions: DRY



---
class: inverse

# Functions: Conditionals



---
class: inverse

# Functions: Anonymous Functions



---
class: inverse

# Functions: Exercises



---
class: inverse 

# More

<br>
<br>
<i class="fab fa-r-project fa-5x"></i>

---
class: inverse

# More: Code Style



---
class: inverse

# More: Vectorization



---
class: inverse

# More: Regular Expressions



---
class: inverse

# More: Exercises


---
class: last-slide, inverse, center, middle



![](https://github.com/m-clark/m-clark.github.io/raw/master/img/Rlogo.svg)


